"use strict";
const sequelize = require("../models/index").sequelize;
const messages = require("../helpers/message");
const _ = require("lodash");
const { QueryTypes, Op } = require("sequelize");

async function getProducts(query) {
  try {
    let iql = "";
    let count = 0;

    if (query && Object.keys(query).length) {
      iql += `WHERE `;

      if (query.productId) {
        iql += count >= 1 ? ` AND` : ``;
        count++;
        iql += ` p.product_id = '${query.productId}'`;
      }

      if (query.productNo) {
        iql += count >= 1 ? ` AND` : ``;
        count++;
        iql += ` p.product_no LIKE '%${query.productNo}%'`;
      }

      if (query.productName) {
        iql += count >= 1 ? ` AND` : ``;
        count++;
        iql += ` p.product_name LIKE '%${query.productName}%'`;
      }

      if (query.fabricName) {
        iql += count >= 1 ? ` AND` : ``;
        count++;
        iql += ` p.fabric_name LIKE '%${query.fabricName}%'`;
      }

      // Remove the isActive filter to show all products
    }

    // Remove the automatic is_active filter to show ALL products
    // if (!query?.isActive && !iql.includes("p.is_active")) {
    //   iql += count >= 1 ? ` AND` : `WHERE`;
    //   iql += ` p.is_active = 1`;
    // }

    const result = await sequelize.query(
      `SELECT 
        p.product_id as "productId",
        p.product_no as "productNo",
        p.product_name as "productName",
        p.product_composition as "productComposition",
        p.size,
        p.fabric_name as "fabricName",
        p.washing_details as "washingDetails",
        p.filling_material as "fillingMaterial",
        p.moq as "moq",
        p.packaging as "packaging",
        p.low_quantity_price as lowQuantityPrice,
        p.medium_quantity_price as mediumQuantityPrice,
        p.high_quantity_price as highQuantityPrice,
        p.product_image as "productImage",
        p.is_active as "isActive",
        p.created_at as "createdAt",
        p.updated_at as "updatedAt",
        p.created_by as "createdBy",
        p.updated_by as "updatedBy",
        emp_created.employee_name as "createdByName",
        emp_updated.employee_name as "updatedByName"
      FROM products p
      LEFT JOIN employees emp_created ON emp_created.employee_id = p.created_by
      LEFT JOIN employees emp_updated ON emp_updated.employee_id = p.updated_by
      ${iql}
      ORDER BY p.created_at DESC`,
      {
        type: QueryTypes.SELECT,
        raw: true,
        nest: false,
      }
    );

    return result;
  } catch (error) {
    throw new Error(error.message ? error.message : messages.OPERATION_ERROR);
  }
}

async function createProduct(postData, userId) {
  const transaction = await sequelize.transaction();

  try {
    const excuteMethod = _.mapKeys(postData, (value, key) => _.snakeCase(key));

    // Check for duplicate product number
    const existingProduct = await sequelize.models.product.findOne({
      where: { product_no: excuteMethod.product_no },
      transaction,
    });

    if (existingProduct) {
      throw new Error(
        "Product number already exists" + messages.DUPLICATE_ENTRY
      );
    }

    // UUID will be automatically generated by the database
    excuteMethod.created_by = userId;

    const productResult = await sequelize.models.product.create(excuteMethod, {
      transaction,
    });

    await transaction.commit();

    const req = { productId: productResult.product_id };
    return await getProducts(req);
  } catch (error) {
    await transaction.rollback();
    throw new Error(error?.message ? error.message : messages.OPERATION_ERROR);
  }
}

async function updateProduct(productId, putData, userId) {
  const transaction = await sequelize.transaction();

  try {
    const excuteMethod = _.mapKeys(putData, (value, key) => _.snakeCase(key));

    // Check for duplicate product number (excluding current product)
    if (excuteMethod.product_no) {
      const existingProduct = await sequelize.models.product.findOne({
        where: {
          product_no: excuteMethod.product_no,
          product_id: { [Op.ne]: productId },
        },
        transaction,
      });

      if (existingProduct) {
        throw new Error(
          "Product number already exists" + messages.DUPLICATE_ENTRY
        );
      }
    }

    excuteMethod.updated_by = userId;

    const [affectedRows] = await sequelize.models.product.update(excuteMethod, {
      where: { product_id: productId },
      transaction,
    });

    if (affectedRows === 0) {
      throw new Error("Product not found");
    }

    await transaction.commit();

    const req = { productId };
    return await getProducts(req);
  } catch (error) {
    await transaction.rollback();
    throw new Error(error?.message ? error.message : messages.OPERATION_ERROR);
  }
}

async function deleteProduct(productId, userId) {
  const transaction = await sequelize.transaction();

  try {
    const [affectedRows] = await sequelize.models.product.update(
      {
        is_active: 0,
        updated_by: userId,
      },
      {
        where: { product_id: productId },
        transaction,
      }
    );

    if (affectedRows === 0) {
      throw new Error("Product not found");
    }

    await transaction.commit();
    return { message: "Product deleted successfully" };
  } catch (error) {
    await transaction.rollback();
    throw new Error(error?.message ? error.message : messages.OPERATION_ERROR);
  }
}

async function bulkUploadProducts(products, userId) {
  const transaction = await sequelize.transaction();

  try {
    const results = {
      successCount: 0,
      failedCount: 0,
      failedProducts: [],
    };

    console.log(
      `Starting bulk upload for ${products.length} products, user: ${userId}`
    );

    for (const productData of products) {
      try {
        console.log(`Processing product: ${productData.productNo}`);

        // Map and prepare data for database
        const mappedProductData = {
          product_no: String(productData.productNo).trim(),
          product_name: String(productData.productName).trim(),
          product_composition: String(productData.productComposition).trim(),
          size: String(productData.size).trim(),
          fabric_name: String(productData.fabricName).trim(),
          washing_details: String(productData.washingDetails).trim(),
          // Parse price fields as numbers
          low_quantity_price: parseFloat(productData.low_quantity_price) || 0,
          medium_quantity_price:
            parseFloat(productData.medium_quantity_price) || 0,
          high_quantity_price: parseFloat(productData.high_quantity_price) || 0,
          filling_material: productData.fillingMaterial
            ? String(productData.fillingMaterial).trim()
            : null,
          moq: String(productData.moq).trim(),
          packaging: productData.packaging
            ? String(productData.packaging).trim()
            : null,
          product_image: productData.productImage
            ? String(productData.productImage).trim()
            : null,
          is_active: productData.isActive !== false,
          created_by: userId,
          updated_by: userId,
        };

        // Check for duplicate product number
        const existingProduct = await sequelize.models.product.findOne({
          where: { product_no: mappedProductData.product_no },
          transaction,
        });

        if (existingProduct) {
          // Update existing product
          await existingProduct.update(mappedProductData, { transaction });
          console.log(`Updated existing product: ${productData.productNo}`);
        } else {
          // Create new product
          await sequelize.models.product.create(mappedProductData, {
            transaction,
          });
          console.log(`Created new product: ${productData.productNo}`);
        }

        results.successCount++;
      } catch (error) {
        console.error(
          `Failed to process product ${productData.productNo}:`,
          error.message
        );
        results.failedCount++;
        results.failedProducts.push({
          productNo: productData.productNo,
          productName: productData.productName,
          error: error.message,
        });
      }
    }

    await transaction.commit();
    console.log(
      `Bulk upload completed: ${results.successCount} successful, ${results.failedCount} failed`
    );
    return results;
  } catch (error) {
    await transaction.rollback();
    console.error("Bulk upload service error:", error);
    throw error;
  }
}

module.exports = {
  getProducts,
  updateProduct,
  createProduct,
  deleteProduct,
  bulkUploadProducts,
};
